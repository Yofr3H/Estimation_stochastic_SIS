### A Pluto.jl notebook ###
# v0.14.7

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    quote
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : missing
        el
    end
end

# ╔═╡ cc938745-4775-480d-90c4-9e2692ca2b4e
begin
    #import Pkg
    #Pkg.activate(mktempdir())
    #Pkg.add([
    #    Pkg.PackageSpec(name="Plots", version="0.29.9"),
    #    Pkg.PackageSpec(name="PlutoUI", version="0.7.1"),
    #    Pkg.PackageSpec(name="Distributions", version="0.23.8"),
    #    Pkg.PackageSpec(name="LaTeXStrings", version="1.3.0"),
    #  	Pkg.PackageSpec(name="Random"),
    #    Pkg.PackageSpec(name="PlotlyJS", version="0.14.1"),
    #    Pkg.PackageSpec(name="DataFrames", version="0.21.8"),
    #    Pkg.PackageSpec(name="CSV", version="0.9.10"),
    #	 Pkg.PackageSpec(name="ORCA", version="0.5.0"),
    #   Pkg.PackageSpec(name="Pluto", version="0.14.7")
    # ])
    using Plots, ORCA, PlutoUI, Distributions, LaTeXStrings, Random, PlotlyJS, DataFrames, CSV
end

# ╔═╡ 87f5c872-4435-11ec-07e4-6ba03780c882
#  Creates a trayectory of SIS model where the infection rate is time dependent and has a random noise 
#  S_n,I_n,R_n
#  T is the steps number.

# ╔═╡ 8a7be597-266c-4f02-b7b6-eea924c45fa3
begin
		function SDE_SIS(k::Float64,Ci::Float64,Cs::Float64,T::Int64,Time::Int64,h::Float64,Time_latency::Int64,mean::Float64,desvest::Any,gamma::Float64,beta::Any,I0::Any)
		#SIS(N,T,h,mean,desvest,nu,beta,S0,I0,R0)
		#initial disease rate
		bt = beta[1]
		S1 = zeros(T*Time + 1,3)
		#Initialization of I_0 S_0 and C_0
		S1[1,2] = I0[1] #I_0
		S1[1,1] = 1.0 - I0[1] #S_0
		S1[1,3] = k + Ci*S1[1,2] #Cost_n: k + Cs*S1[1,1];
		# SDE SIS EVOLUTION
		desv = desvest[1]
		for i=1:(Time*T)
			#I_current = S1[i,2]
			if i % (Time_latency*T)  == 0 #change the infected rate each T steps or each day
				bt = beta[Int(i / T)]
				if (length(desvest)>1)
					desv = desvest[Int(i / T)] #
				end
			end
			if i % (Time_latency * T )  == 0
			   #bt = beta[ Int(i / T) ] # change the infected each latency period
			   S1[i+1,2] = I0[Int(i / T) + 1 ]
			   S1[i+1,1]= 1.0 - S1[i+1,2]
			   S1[i+1,3]= S1[i,3] + Ci*S1[i+1,2]
			else
				# generates the random noise
				z=rand(Normal(mean,desv))
				#evaluate Infected next  step - rate infection with additive noise
				S1[i+1,2]= S1[i,2]+ (bt + z)*(1.0 - S1[i,2])*S1[i,2]*h - gamma*S1[i,2]*h;#Infected
				#evaluate Infected next  step - rate infection with proportional noise
				#S1[i+1,2]= S1[i,2] + bt*(1.0 + z)*(1.0 - S1[i,2])*S1[i,2]*h - gamma*S1[i,2]*h;#Infected
				S1[i+1,1]= 1.0 - S1[i+1,2]
				S1[i+1,3]= S1[i,3] + Ci*S1[i+1,2]
			end
		end
		#show(stdout, S1[:,2])
		S=S1[1:T:(T*Time + 1),1];
		I=S1[1:T:(T*Time + 1),2];
		C=S1[1:T:(T*Time + 1),3];
		return [S I C]
	end
end


# ╔═╡ 242e1093-dbaa-41c1-ad33-7521738b2ec1
begin
	r = CSV.read("rate.csv",DataFrame)	
	plotlyjs()
	p = Plots.plot(1:length(r.I0),r.I0,
		label="Number infected per day",color="orange",
		title="Infected historical data",
		size = (675, 200),legend=:top, titleposition = :left,
		titlefonthalign=:left)
end

# ╔═╡ 0bc6dd10-eaca-4f96-95ac-78d974ca0a22
begin
   slider_replications = @bind replications Slider(100:100:1000, default=500,show_value=true)
	#Time_latency = 5# number of predicted days using the same beta
	slider_Time_latency = @bind Time_latency Slider(2:15, default= 5,show_value=true)
	md"""
	**Number of replications: $slider_replications.**
	**Time latency: $slider_Time_latency**
	"""
end

# ╔═╡ ac40fe33-3b7c-4328-a03b-04fe369174b8
begin
	# T is time subdivisions per day
	slider_T = @bind T Slider(10:100:1000,show_value=true)
	# Confidence level
	#T = 50
	slider_confidence_level = @bind confidence_level Slider(0.01:0.01:0.05,show_value=true)
	md"""
	**Subdvisions per day: $slider_T.**
	**Confidence level (α): $slider_confidence_level**
	"""
end

# ╔═╡ c724ac1d-c7b4-4e37-9d5a-aa41130dcb99
begin
	select_beta_estimator_method = @bind beta_alternative Select(["Beta_estimator_2_steps","LLGMM_scheme"])
	select_standard_deviation = @bind sigma_alternative Select(["Fixed","Generated by LLGMM_scheme"])
	md"""
	**Method to estimate beta: $select_beta_estimator_method**
	
	**Standard deviation: $select_standard_deviation**
	"""
end

# ╔═╡ 6826f12e-6b0d-4281-ad91-8d8a73b3c8bf
begin
	if (sigma_alternative == "Fixed")
		desvest = zeros(1)
		slider_desvest = @bind val Slider(0.1:0.1:0.90, default = 0.2, show_value=true)
		desvest[1] = val
		md"""
		**σ: $slider_desvest.**
		"""
	else
		desvest = zeros(length(r.I0) - 1)
	s = show(desvest)
	end
end

# ╔═╡ 8eb8ffca-2b6f-4b44-86b7-e35f14e8de8a
begin
	if (beta_alternative == "Beta_estimator_2_steps") & (sigma_alternative == "Fixed") 
			m_k = 1
		    w = show(m_k)
		
	else
	# (beta_alternative == "LLGMM_scheme") | (sigma_alternative == "Generated by LLGMM_scheme")
		# reverse sample used to generate the beta estimator
		slider_mk = @bind m_k Slider(2:15,default=5,show_value=true)
		md"""
		**Size sample (mk) LLGMM scheme: $slider_mk.**
		"""
		#m_k =5 #sample size - otunuga
	end	
end

# ╔═╡ c339772d-1a72-4c6a-bc92-934e20ef66bf
begin
   	slider_center_iconfidence = @bind center_iconfidence Slider(0.5:0.05:0.95, default = 0.5,show_value=true );
	slider_min_I0 = @bind I0_min Slider(m_k:(length(r.I0) - Time_latency),
		show_value=true);
   #default = m_k
	md"""
	**Confidence interval centered in quantile: $slider_center_iconfidence**
	
	**Initial day = $slider_min_I0**
	"""
	
end


# ╔═╡ f93ed310-371c-4aa7-9466-dcbb8222db1f
begin
	slider_max_I0 = @bind I0_max Slider((I0_min + 1) :length(r.I0), 
							default = (I0_min + m_k + Time_latency),
							show_value=true)
	#
	md"""
	**Final day = $slider_max_I0**
	"""
end

# ╔═╡ 0328ab6d-5f33-4dc7-9dc2-0bb09e578335
begin
	select_view = @bind view_obj Select(["Infected estimation",
			"Suceptible estimation",
			"Cost estimation"
			]
			)
	md"""
	**Visualization: $select_view**
	"""	
end

# ╔═╡ 27c33b01-3b54-4b5f-992c-44a9647ee022
begin
	if (view_obj == "Cost estimation") 
	text_k  = @bind k PlutoUI.NumberField(40.0:0.01:100.0,default=40.0)
	text_Cs = @bind Cs NumberField(1.0:0.01:10.0,default=3.0)
	text_Ci = @bind Ci NumberField(1.0:0.01:10.0,default=4.0)
	md"""**Fixed cost: $text_k.**$\text{ }$ 
	**Unit cost succeptible patient attention: $text_Cs.** 
	**Unit cost succeptible infected attention: $text_Ci.**
	"""
	else
		k = 0.0
		Cs = 0.0
		Ci = 0.0
		nview = show(Ci)
	end
end

# ╔═╡ 85e80cd5-8053-414a-ab1a-8e831faaba5d
begin
	#N = 133870037;#mexico
	# N=S+I+R:Population N=48258494.0;
	N = r.N[1] # N population size
	I_scaled = N^(-1) * r.I0;
	I_0 = I_scaled[I0_min:I0_max] 
	beta = zeros(Float64,length(I_0))
	#
	#size 367
	#Time = 290 - 1 #days
	#Time_latency = 6# number of predicted days with equal beta value
	h = 1 / T;
	# h=t_{N+1}-t_{N}
	gamma = Float64(1/15)
	## data
	# 2.54405E-06;#0.0002508;  # nu:=recovery rate nu=5.5258E-09;
	#I0 = 383.0;              # Infected people in t=0
	#I0 = 2145.0
	### I_0 guadalajara
	mean_noise = 0.0            
	# c=1.0; # c=:fixed cost to care for a patient.
	#k = 40.0;
	#Cs = 3.0;
	#Ci = 4.0;
	#
	# Beta Alternative 1
	if (beta_alternative == "Beta_estimator_2_steps")
	 	for i in 1:(length(I_0)-1)
	     	beta[i] = Float64(N * (r.I0[i+1]- r.I0[i] 
					+(gamma)*r.I0[i])/((N - r.I0[i])*r.I0[i]))
	 	end # beta associated to I_1 ,...., I_n (excludes to I_0)
	end
	#
	## Beta Alternative_2:  otunuga beta-estimation
	#m_k =5 #sample size - otunuga
	Time =  length(I_0) - 1 - m_k
	#k   =   m_k
	for i   =   (m_k + 1):(length(I_0) - 1)
		mean_I  =   zeros(m_k)
		if (sigma_alternative == "Generated by LLGMM_scheme")
			denominador = 0.0
			numerador = 0.0
			for k = (i-m_k +1):i
				for s = 1:k
					numerador = numerador + (1/k)* (I_0[s+1]-I_0[s])^2
				end
				denominador = denominador + (1-I_0[k])^2*I_0[k]^2
			end
			desvest[i] = numerador/denominador
			mean_I[1] = I_0[2] - I_0[1] + gamma*I_0[2]
						- desvest[i]^2/2*(1-I_0[2])*(1-2*I_0[2])*I_0[2]
		#	mean_I[1]   =  (1/2)*(I_0[3]  -   I_0[1])  + ...
		end
		
		if (sigma_alternative == "Fixed")	
			mean_I[1] = I_0[i - m_k + 2] - I_0[i - m_k] + gamma*I_0[i - m_k + 1]
						- desvest[1]^2*0.5*(1 - I_0[i - m_k + 1])*(1 
						- 2*I_0[i - m_k + 1])*I_0[i - m_k + 1]
		end
		serie_denominator = (1 - I_0[i - m_k + 1])*I_0[i - m_k + 1]
		# Δt =   1   day
		for j = 1:(m_k - 1)
			aux = ( 1/(j + 2) )*( I_0[i - m_k + 1 + j] - I_0[i - m_k] )
				+ gamma*I_0[i - m_k + 1 + j]
			if (sigma_alternative == "Fixed")
				mean_I[j + 1] = aux - (desvest[1]^2)*(0.5)*(1 
									- I_0[i - m_k + 1 + j])*(1 
									- 2*I_0[i- m_k + 1 + j])* I_0[i - m_k + 1 + j]
			end
			serie_denominator = serie_denominator + (1 
								- I_0[i - m_k + 1 + j]) * I_0[i - m_k + 1 + j]
			if (sigma_alternative == "Generated by LLGMM_scheme")
				mean_I[j + 1] = aux - (desvest[i]^2)*(0.5)*(1 
										- I_0[i - m_k + 1 + j])*(1 
										- 2*I_0[i - m_k + 1 + j])*I_0[i - m_k + 1 + j]
			end
		end
		if (beta_alternative == "LLGMM_scheme")
			beta[i] = sum(mean_I) / serie_denominator
		end
	end
		
	Trajectorie = zeros(replications,Time + 1);
	confidence_interval = zeros(Time + 1,2)
	mean_trajectorie = zeros(Time + 1,1)
	time_plot_trajectory = 0:(Time);
	M = SDE_SIS(k,Ci,Cs,T,Time,h,Time_latency,mean_noise,desvest,gamma,
				beta[(m_k + 1):end],I_0[(m_k + 1):end]
				)

	S1 = M[:,1];
	I1 = M[:,2];
	C1 = M[:,3];
	if (view_obj == "Infected estimation")
		Trajectorie[1,:] = I1#I
	end
	if (view_obj == "Suceptible estimation")
		Trajectorie[1,:] = S1#I
	end
	if (view_obj == "Cost estimation")
		Trajectorie[1,:] = C1#I
	end
	
	graf = Plots.plot(time_plot_trajectory,Trajectorie[1,:],label="",color="green")#I
	
	for i = 2:(replications - 1)
		Mi = SDE_SIS(k,Ci,Cs,T,Time,h,Time_latency,mean_noise,desvest,gamma,
					beta[m_k + 1:end],I_0[(m_k + 1):end]
					)
		Si = Mi[:,1];
		Ii= Mi[:,2];
		Cii = Mi[:,3];
		if (view_obj == "Infected estimation")
			Trajectorie[i,:] = Ii#I
		end
		if (view_obj == "Suceptible estimation")
		Trajectorie[i,:] = Si#I
		end
		if (view_obj == "Cost estimation")
			Trajectorie[i,:] = Cii#I
		end

		plot!(graf,time_plot_trajectory,Trajectorie[i,:],color="green",label="")#I
		
	end
	
	Mf = SDE_SIS(k,Ci,Cs,T,Time,h,Time_latency,mean_noise,desvest,gamma,
				beta[m_k + 1:end],I_0[m_k + 1:end]
				)
	
	Sf = Mf[:,1];
	If = Mf[:,2];
	Cf = Mf[:,3];
	if (view_obj == "Infected estimation")
		Trajectorie[replications,:] = If#I
	end
	if (view_obj == "Suceptible estimation")
		Trajectorie[replications,:] = Sf#I
	end
	if (view_obj == "Cost estimation")
		Trajectorie[replications,:] = Cf#I
	end
	
	plot!(graf,time_plot_trajectory,Trajectorie[replications,:],
		color="green",label="")#I
	
	for i = 1:(Time + 1)
		dat = Trajectorie[:,i]
		SE = std(dat)/sqrt(length(dat))
		tstar = quantile(TDist(length(dat)-1), 1 - confidence_level/2)
		#average = sum(dat)/length(dat)
		iconf_center = quantile(dat,center_iconfidence)#0.5 default
		confidence_interval[i,1] = iconf_center -  tstar * SE
		confidence_interval[i,2] = iconf_center +  tstar * SE
		mean_trajectorie[i,1] = iconf_center
	end
	
	if (view_obj == "Cost estimation")
		plot!(graf,title = "Cost evolution")
	end
	
	plot!(graf,time_plot_trajectory,confidence_interval[:,1],
		color="red",label="L  i_conf",lw=3)
	plot!(graf,time_plot_trajectory,mean_trajectorie[:,1],
		color="black",label="Mean estimation",lw=2)
	plot!(graf,time_plot_trajectory,confidence_interval[:,2],
		color="red",label="U  i_conf",lw=3) # î_t 
	
	error_vector = zeros(Float64,length(I_0))
	if (view_obj == "Infected estimation")
		plot!(graf,time_plot_trajectory,I_0[1:(Time + 1)],
			color="orange",title = "Infected evolution",label="I_t",lw=2)
		error_vector = I_0
	end
	if (view_obj == "Suceptible estimation")
		plot!(graf,time_plot_trajectory,1.0 .- I_0[1:(Time + 1)],
			color="orange",title = "Suceptible evolution",label="S_t",lw=2)
		error_vector = 1.0 .- I_0
	end

	
	relative_error = zeros(length(error_vector)-(m_k + 1))
	max_relative_error =  zeros(Int(floor(length(relative_error) / Time_latency)))
	for i in 1:(length(error_vector)-(m_k + 1))
		relative_error[i] =  abs(error_vector[m_k + i] 
							- mean_trajectorie[i]) / error_vector[i]
		if (i % Time_latency == 0)
			index = Int(i / Time_latency)
			max_relative_error[index] = 
			maximum(relative_error[(i - (Time_latency -1)):i ])
		end
	end
	plotlyjs()
	Plots.plot(graf,size = (675, 450),legend=:top, titleposition = :left,
		titlefonthalign=:left)
end

# ╔═╡ b6aa550b-5d5f-4701-b1fd-33af85b125f2
begin
	if (view_obj != "Cost estimation")
	plotlyjs()
	error = Plots.plot(1:(length(I_0)-(m_k + 1)),relative_error,
			color="black", title="Relative errors",label ="Relative error" ,
			lw=1,size = (675, 350),legend=:top, titleposition = :left,
			titlefonthalign=:left)
	end
end

# ╔═╡ Cell order:
# ╟─87f5c872-4435-11ec-07e4-6ba03780c882
# ╟─cc938745-4775-480d-90c4-9e2692ca2b4e
# ╟─8a7be597-266c-4f02-b7b6-eea924c45fa3
# ╟─242e1093-dbaa-41c1-ad33-7521738b2ec1
# ╟─0bc6dd10-eaca-4f96-95ac-78d974ca0a22
# ╟─ac40fe33-3b7c-4328-a03b-04fe369174b8
# ╟─c724ac1d-c7b4-4e37-9d5a-aa41130dcb99
# ╟─6826f12e-6b0d-4281-ad91-8d8a73b3c8bf
# ╟─8eb8ffca-2b6f-4b44-86b7-e35f14e8de8a
# ╟─c339772d-1a72-4c6a-bc92-934e20ef66bf
# ╟─f93ed310-371c-4aa7-9466-dcbb8222db1f
# ╟─0328ab6d-5f33-4dc7-9dc2-0bb09e578335
# ╟─27c33b01-3b54-4b5f-992c-44a9647ee022
# ╟─85e80cd5-8053-414a-ab1a-8e831faaba5d
# ╟─b6aa550b-5d5f-4701-b1fd-33af85b125f2
